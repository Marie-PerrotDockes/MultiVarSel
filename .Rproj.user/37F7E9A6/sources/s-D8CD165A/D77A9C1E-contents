LR.stat <- function(E, SigmaM12.H0, SigmaM12.H1, forcePD = FALSE) {
    n <- nrow(E)
    S <- crossprod(E)/n
    
    SigmaM1.H0 <- crossprod(SigmaM12.H0)
    if (forcePD) {
        SigmaM1.H1 <- nearPD(crossprod(SigmaM12.H1))$mat
    } else {
        SigmaM1.H1 <- crossprod(SigmaM12.H1)
    }
    log.det0 <- as.numeric(determinant(SigmaM1.H0, logarithm=TRUE)$modulus)
    log.det1 <- as.numeric(determinant(SigmaM1.H1, logarithm=TRUE)$modulus)
    
    return( n*(log.det1-log.det0 + sum(diag((SigmaM1.H0-SigmaM1.H1) %*% S))) )
}

plot.abacus <- function(beta, p, plot=TRUE, main="") {
    B <- Matrix(as.numeric(beta), nrow=p, byrow=TRUE)
    abacus <- sapply(1:nrow(B), function(i) i * (B[i, ] != 0))    
    if(plot)
        matplot(abacus, pch=20, ylim=c(1,p), main=main)
    invisible(abacus)
}

get.perf.manova <- function(manova, data, type="validation") {

    beta.hat <- coefficients(manova)
    mse <- perf.mse(beta.hat,data$beta)
    err <- mean((data$y[data$test, ]-data$x[data$test, ] %*% beta.hat)^2)

    pval <-sapply(summary(manova), function(M) {
        return(M$coefficients[, "Pr(>|t|)"])
    })

    thr <- seq(min(pval), max(pval), len=100)
    supp.hat <- lapply(thr, function(th) 1*(pval <= th))
    roc <- t(sapply(supp.hat, function(beta) perf.roc(beta,data$beta)))
    auc <- perf.auc(as.data.frame(roc))
    return(list(roc = roc, auc = auc, mse = mse, err = err))    
}

get.perf <- function(fit, data) {
    
    err.valid <- get.error.vec(fit, data$x[data$valid, ], data$y[data$valid, ])
    beta.hat <- Matrix(fit$beta[, which.min(err.valid)], p, q)
    
    roc <- t(apply(fit$beta, 2, function(beta) perf.roc(beta,data$beta)))
    auc <- perf.auc(as.data.frame(roc))
    mse <- perf.mse(beta.hat,data$beta)
    err <- mean((data$y[data$test, ]-data$x[data$test, ] %*% beta.hat)^2)
    return(list(roc = roc, auc = auc, mse = mse, err = err))
}

get.error.vec <- function(fit, x, y) {    
    y.vec <- as.vector(y)
    x.vec <- bdiag(rep(list(x), ncol(y)))
    return(colMeans((y.vec - predict(fit, newx=x.vec))^2))
}


mse <- function(theta, theta.star) {
  return(mean(as.vector(theta.star-theta)^2, na.rm=TRUE))
}

perf.mse <- function(theta.hat, theta.star) {

  if (is.list(theta.hat)) {
    return(sapply(theta.hat, mse, theta.star))
  } else {
    return(mse(theta.hat, theta.star))
  }
}

perf.roc <- function(theta.hat, theta.star) {

  roc <- function(theta) {
    nzero <- which(theta != 0)
    zero  <- which(theta == 0)

    true.nzero <- which(theta.star != 0)
    true.zero  <- which(theta.star == 0)

    TP <- sum(nzero %in% true.nzero)
    TN <- sum(zero %in%  true.zero)
    FP <- sum(nzero %in% true.zero)
    FN <- sum(zero %in%  true.nzero)

    recall    <- TP/(TP+FN) ## also recall and sensitivity
    fallout   <- FP/(FP+TN) ## also 1 - specificit

    res <-  round(c(fallout,recall),3)
    res[is.nan(res)] <- 0
    names(res) <- c("fallout","recall")
    return(res)
  }

  if (is.list(theta.hat)) {
    return(as.data.frame(do.call(rbind, lapply(theta.hat, roc))))
  } else {
    return(roc(theta.hat))
  }
}

perf.auc <- function(roc) {
  fallout <- c(0,roc$fallout,1)
  recall  <- c(0,roc$recall, 1)
  dx <- diff(fallout)
  return(sum(c(recall[-1]*dx, recall[-length(recall)]*dx))/2)
}

