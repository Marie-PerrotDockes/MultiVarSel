#' Estimate the inverse of the square root of the covariance matrix of each line of the residuals matrix.
#'
#' @param residuals  matrix of residuals of the classical linear model without taking into account the dependence between the columns of the observations matrix.
#' @param typeDep A character specifying the type of dependance can be :"AR1", "no_whitening", "nonparam" or "ARMA".
#' @param pAR In the case where typeDep="ARMA" it corresponds to the parameter p of the ARMA(p,q) modelling.
#' #' @param pAR In the case where typeDep="ARMA" it corresponds to the parameter q of the ARMA(p,q) modelling.
#' @return the estimation of the inverse of the square root of the covariance matrix of each line of residuals.
#' @examples
#' n <- 100; p <- 10
#' X <- matrix(rnorm(n*p), n, p)
#' beta <- runif(p, 1, 2) * sample(c(-1,1), p, rep=TRUE)
#' y <- X %*% beta + rnorm(n)
#' OLS(X,y)
#' @export
whitening <- function (residuals, typeDep = 'AR1', pAR = 1, qMA = 0){
  n = dim(residuals)[1]
  q = dim(residuals)[2]
  if (typeDep == "no_whitening") {
    return(Diagonal(q, 1))
  }
  if (typeDep == "AR1") {
    phi_hat <- sum(diag(crossprod(residuals[, -q], residuals[, -1])))/sum(diag(crossprod(residuals)))
    d1 <- c(sqrt(1 - phi_hat ^ 2), rep(1, q - 1))
    d2 <- c(rep(- phi_hat, q - 1))
    square_root_inv_hat_Sigma <- bandSparse(q, k = 0:1, diag = list(d1, d2))
    return(square_root_inv_hat_Sigma)
  }
  if (typeDep == "ARMA") {
    phi_hat = matrix(0, n, max(pAR, 1))
    theta_hat = matrix(0, n, max(qMA, 1))
    if ((pAR >= 1) && (qMA >= 1)) {
      for (i in 1:n) {
        phi_hat[i, ] = arima(residuals[i, ], order = c(pAR, 
                                                       0, qMA))$coef[1:pAR]
        theta_hat[i, ] = arima(residuals[i, ], order = c(pAR, 
                                                         0, qMA))$coef[(pAR + 1):(pAR + qMA)]
      }
    }
    if ((pAR >= 1) && (qMA == 0)) {
      for (i in 1:n) {
        phi_hat[i, ] = arima(residuals[i, ], order = c(pAR, 
                                                       0, qMA))$coef[1:pAR]
      }
    }
    if ((pAR == 0) && (qMA >= 1)) {
      for (i in 1:n) {
        theta_hat[i, ] = arima(residuals[i, ], order = c(pAR, 
                                                         0, qMA))$coef[(pAR + 1):(pAR + qMA)]
      }
    }
    phi_hat_final = colMeans(phi_hat)
    theta_hat_final = colMeans(theta_hat)
    acf_theo_hat = ARMAacf(ar = phi_hat_final, ma = theta_hat_final, 
                           lag.max = (q - 1))
    psi_hat = ARMAtoMA(ar = phi_hat_final, ma = theta_hat_final, 
                       1000)
    variance_hat = 1 + sum(psi_hat^2)
    Sigma_hat = toeplitz(acf_theo_hat) * variance_hat
    square_root_inv_hat_Sigma = Matrix(round(solve(chol(Sigma_hat)), 
                                             digits = 6))
    return(square_root_inv_hat_Sigma)
  }
  if (typeDep == "nonparam") {
    vector_cov = matrix(0, n, q)
    for (i in 1:n) {
      vector_cov[i, ] = acf(residuals[i, ], type = "covariance", 
                            plot = FALSE, lag.max = (q - 1))$acf
    }
    vector_cov_estim = colMeans(vector_cov)
    cov_matrix = toeplitz(vector_cov_estim)
    square_root_inv_hat_Sigma = Matrix(round(solve(chol(cov_matrix)), 
                                             digits = 6))
    return(square_root_inv_hat_Sigma)
  }
}