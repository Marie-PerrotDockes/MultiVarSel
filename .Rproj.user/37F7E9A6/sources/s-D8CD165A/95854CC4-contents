---
title: "Guide d'utilisation des fonctions"
author: "Marie"
date: "3 avril 2017"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

\section{ Chargement /Simulation des données}
```{r}
setwd('~/Documents/Rupture_moyenne/Data/Multivar_selec')
load('~/Documents/Rupture_moyenne/Data/Multivar_selec/Data/data_Tmod_sspdc.RData')
source('~/Documents/Rupture_moyenne/Data/Multivar_selec/Functions/cv_fus.R')
library(Matrix)
library(knitr)
library(pracma)
#library(FusedLasso,lib.loc = '/mnt/mmip/perrotdockes')
 library(FusedLasso)
require(tseries)
require(ggplot2)
require(Matrix)
#require(doBy)
require(reshape2)
library(glmnet)
library(parallel)
library(RColorBrewer)
library(MASS)
X_dc<-X_dc[,1:12] #On garde que 5 variable pouyr cet exemple
X_bxcx<-X_bxcx[,1:6]
p<-ncol(X_dc)
q<-ncol(Y_bxcx)
n<-nrow(X_bxcx)
## Simulation de B :
B=Matrix(rep(0,p*q),nrow=p, ncol=q,sparse=TRUE)
rownames(B)<-colnames(X_dc)
colnames(B)<-colnames(Y_bxcx)
# le scenario 1 aura :
nlevs<-nlevels(dc)
cate<-dc
#Disons 5 inputs gardés pour tous les perturbateurs par outputs et 5 inputs gardé pour la moitié des perturbateurs par output
# on ne prend pas en compte des inputs qui ne marche que pour un pert pour l'instant
nb<-floor(ncol(X_bxcx)/3)
par_out<-function(out){
  samp_allfus<-sample(c(0:(ncol(X_bxcx)-1)),nb)
  samp_halffus<-sample(c(0:(ncol(X_bxcx)-1))[-c(samp_allfus+1)],nb)

  B[c(1:nlevs)+rep(nlevs*samp_allfus,each=nlevs),out]<<-1

  B[c(sapply(1:nb,function(i){sample(1:nlevs,round(nlevs/2))}))+rep(nlevs*samp_halffus,each=round(nlevs/2)),out]<-1
return(list(samp_allfus,samp_halffus))
      }

Select<-lapply(1:q,par_out)

names(Select)<-colnames(B)
apply(B,2,sum)


# save(Select,B,file='B_scenario1_grpinp.RData')
# load('B_scenario1_grpinp.RData')
```

## Prépararion du graphe : 
Nb : le graphe ne dépend que de X et du nombre de collone de Y si on fait plusieurs simulations de Y on est pas obligé de
recalculer le graphe à chaque fois 

```{r}
Recup_pote<-function(i){
  grep(i,colnames(X_dc))
  
}

Potes<- lapply(rep(colnames(X_bxcx),each=nlevels(cate)), Recup_pote)
Potes<-c(rep(list(c(1:nlevels(cate))),nlevels(cate)),Potes)  
que_diff<-function(i){
  as.integer(Potes[[i]][Potes[[i]]!=i])
}  
Potes_int<- lapply(1:length(Potes), que_diff)

## au final pour chaque output il nous faut Potes_int mais decaler du coup ! 
par_out<-function(i){
  ajout<-function(paire){
    paire+length(Potes_int)*(i-1)
  }
  Pts<- lapply(Potes_int,ajout)
  Pts
}
Potes_final<-lapply(1:q,par_out)

Potes_fin<-do.call(c,Potes_final)
Graphe<-lapply(Potes_fin,as.integer)
G2<-list(Graphe,c(rep(list(rep(1,(nlevels(cate)-1))),length(Potes_fin))))
names(G2)<-c('conn','weight')  

```

## Simulation de Sigma  

```{r}
rho<-0.8
sparsity<-0.1
 SNR<-2
 nb_blocks<-3
  a=q/nb_blocks # /!\ il faut a entier
  S1=matrix(rho,nrow=a,ncol=a)+(1-rho)*diag(rep(1,a))
  Sigma=bdiag(rep(list(S1),nb_blocks))
  racine_Sigma=Matrix(round(chol(Sigma),digits=6))
  racine_Sigma_inv=Matrix(round(solve(racine_Sigma),digits=6))
E=matrix(rnorm(n*q,0,1),nrow=n,ncol=q)%*%(racine_Sigma)
Y=X_dc %*% B+E
colnames(Y)<-paste('Y',1:18)

```

\section{Application de la fonction mod_fus_cv}
Fonction a qui on donne commme argument une matrice de design de l'ANCOVA, un matrice de réponse, un graphe et si oui ou non on calcul les 
modèle pour les raw et les erreur de CV.

```{r}
mod<-mod_fus_cv(X_dc,Y_bxcx,G2,nb.core=4,raw=TRUE,CV=T,nfold=3,nb_lmb2=3)
```

\section{ Calcul des Erreurs de types BIC et tous les petits potes}

```{r}
  q<-ncol(Y_bxcx)
    residus=sapply(1:q,function(i){Y_bxcx[,i]-X_dc%*%lm.ridge(as.matrix(Y_bxcx[,i])~X_dc -1)$coef})
  
  Cov=cov(residus)
  Svd=svd(Cov)
  L=dim(Cov)[1]
  vap=rep(0,L)
  ind=which(Svd$d>1e-3)
  vap[ind]=1/sqrt(Svd$d[ind])
  racine_Sigma_inv=Svd$v%*%Diagonal(L,vap)%*%t(Svd$u)
  
  ## vectorisation
  

  Yvec_raw=as.numeric(Y_bxcx) 
  Xvec_raw=kronecker(Diagonal(q,1),X_dc) 
  
  Yvec_eym=as.numeric(Y_bxcx%*%racine_Sigma_inv)
  Xvec_eym=kronecker(t(racine_Sigma_inv),X_dc)

par_rho_snr_simu_pen_mod<-function(pen,type){

  #  ## On lance les graphes :
  # print(rho_snr_simu_pen_mod)
  # rho_snr_simu_pen_mod<-All_poss[rho_snr_simu_pen_mod,]
  # rho<-as.numeric(rho_snr_simu_pen_mod[1])
  # SNR<-as.numeric(rho_snr_simu_pen_mod[2])
  # i<-as.numeric(rho_snr_simu_pen_mod[3])
  # pen<-as.numeric(rho_snr_simu_pen_mod[4])
  # mod<-c('EYM','Raw')[as.numeric(rho_snr_simu_pen_mod[5])]
  # Models<-Mods[[which(c(0.5,0.8)==rho)]][[which(c(5,1)==SNR)]]
  # B<-B*SNR
  out.fl2<-mod[[1]][[pen]][[type]]
  pos<-which(as.numeric(B)!=0)
  negpos<-which(as.numeric(B)==0)
#Y<-mod[[2]] #ici comme on fait qu'une simu c'est tous le temps le meme 
type<-c('EYM','Raw')[type]

  ## vectorisation
  if(type=='Raw'){
    Yv=Yvec_raw
    Xv=Xvec_raw

  }
  if(type=='EYM'){
    Yv=Yvec_eym
    Xv=Xvec_eym
  }


  recup_tp_fp_ri_bic<-function(x){
    TP=length(intersect(which(x!=0),pos))
    TN=length(intersect(which(x==0),negpos))
    FP=length(intersect(which(x!=0),negpos))
    FN=length(intersect(which(x==0),pos))
    TPR=TP/(TP+FN)
    FPR=FP/(FP+TN)
    betahat<-matrix(x,ncol=18)
    # nlev<-nlevels(as.factor(cate))
    Ri<-mean(sapply(1:ncol(betahat),
                    function(j){ARI(paste(betahat[,j],rep(colnames(X_bxcx),each=nlevs)),paste(B[,j],rep(colnames(X_bxcx),each=nlevs)))}))
      nid<-mean(sapply(1:ncol(betahat),
                    function(j){NID(paste(betahat[,j],rep(colnames(X_bxcx),each=nlevs)),paste(B[,j],rep(colnames(X_bxcx),each=nlevs)))}))
    hausd<-hausdorff_dist(as.matrix(betahat),as.matrix(B))
    y_chap<-Xv%*%x
    # comme les coefs sont continues on peut trouver les df en
    #regardcant le nombre de coef unique ( des coefs pas fusé ne seront pas égaux)
    df<-length(unique(x)) #-1 pour les 0
    n<-length(Yv)
    cates<-rep(cate,18)
    par_lev<-function(lev){
      nk<-sum(cates==lev)
      log(sum((Yv[cates==lev]-y_chap[cates==lev])^2)/(nk))
    }

    n_bar<-n/nlevs
    sum_ll<-sum(sapply(levels(as.factor(cate)),par_lev))
    Bicm<-n_bar*sum_ll+(log(length(Yv))*df)


    ## Calcul des 'coefs perfect' on compte que c'est un TP si tous les
    # Ici un positifs est au niveau input et non pas au niveau inputs *perturbateurs
    # Un vrai positifs est si il est fusé tout comme il faut
    # # un faux positifs est si il y' a au moins une valeurs qui devrait etre null alors qu'elle ne l'est pas
    # B_chap_fac<-apply(betahat,2,function(x){as.numeric(as.factor(x))})
    # par_inp<-function(i){
    #   par_out<-function(j){
    #     bhat<-betahat[c(1:nlevs)+rep(nlevs*i,each=nlevs),j]
    #     b<-B[c(1:nlevs)+rep(nlevs*i,each=nlevs),j]
    #     if(all(b==bhat)){
    #       if(sum(b)==0){
    #         return('TN')
    #       } else { 'TP'}
    #     }
    #     if (any(bhat!=b)){
    #       if(length(unique(bhat))>length(unique(b))){
    #         return('FP')
    #       } else{ return('FN')}
    #     }
    #   }
    # 
    #   return(sapply(1:18,par_out))
    # }
    # val<-sapply(c(0:(ncol(X.quanti)-1)),par_inp)
    # val<-table(val)
    # TP<-ifelse(is.na(val['TP']),0,val['TP'])
    # FP<-ifelse(is.na(val['FP']),0,val['FP'])
    # TN<-ifelse(is.na(val['TN']),0,val['TN'])
    # FN<-ifelse(is.na(val['FN']),0,val['FN'])
    # TPR_perfect=TP/(TP+FN)
    # FPR_perfect=FP/(FP+TN)
    return(c(TPR_coef=TPR,FPR_coef=FPR,RI=Ri,NID=nid,hausdorff=hausd,BIC=Bicm))

  }
  results<-apply(as.matrix(out.fl2$beta),2,recup_tp_fp_ri_bic)
  return(cbind(as.data.frame(t(results)),Lambda1=out.fl2$lambda1,Lambda2=out.fl2$lambda2,Mod=type,Rho=0.8,SNR=1))
}
p<-par_rho_snr_simu_pen_mod(1,1)
Result<-mcmapply(FUN=par_rho_snr_simu_pen_mod,pen=c(1,2,1,2),type=c(1,1,2,2))
```
```{r}

```

